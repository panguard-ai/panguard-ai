/**
 * CVE/NVD vulnerability checker using NVD API v2.0
 * CVE/NVD 漏洞檢查器，使用 NVD API v2.0
 *
 * Queries NIST National Vulnerability Database for known CVEs
 * based on detected services and versions.
 * Free API (no key required, rate limited to ~5 requests per 30 seconds).
 *
 * @module @panguard-ai/panguard-scan/scanners/cve-checker
 */

import { createLogger } from '@panguard-ai/core';
import type { PortInfo } from '@panguard-ai/core';
import type { Finding } from './types.js';
import type { Severity } from '@panguard-ai/core';

const logger = createLogger('panguard-scan:cve-checker');

const NVD_API_BASE = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

/** Minimum CVSS score to include (skip low-severity CVEs) */
const MIN_CVSS_SCORE = 4.0;

/** Delay between NVD API requests (ms) to respect rate limits */
const API_DELAY_MS = 6500;

/** Maximum CVEs to return per service */
const MAX_CVES_PER_SERVICE = 5;

/** Request timeout in ms */
const REQUEST_TIMEOUT_MS = 15000;

interface NvdCveItem {
  cve: {
    id: string;
    descriptions: Array<{ lang: string; value: string }>;
    metrics?: {
      cvssMetricV31?: Array<{ cvssData: { baseScore: number; baseSeverity: string } }>;
      cvssMetricV2?: Array<{ cvssData: { baseScore: number } }>;
    };
    references?: Array<{ url: string }>;
  };
}

interface NvdResponse {
  totalResults: number;
  vulnerabilities: NvdCveItem[];
}

/**
 * Map a service name to a CPE keyword for NVD search.
 * Returns null if the service can't be mapped.
 */
function serviceToCpeKeyword(service: string): string | null {
  const lower = service.toLowerCase();
  const mapping: Record<string, string> = {
    'openssh': 'openssh',
    'ssh': 'openssh',
    'apache': 'apache http_server',
    'httpd': 'apache http_server',
    'nginx': 'nginx',
    'mysql': 'mysql',
    'mariadb': 'mariadb',
    'postgresql': 'postgresql',
    'postgres': 'postgresql',
    'redis': 'redis',
    'mongodb': 'mongodb',
    'node': 'node.js',
    'nodejs': 'node.js',
    'docker': 'docker',
    'openssl': 'openssl',
    'php': 'php',
    'python': 'python',
    'tomcat': 'tomcat',
    'iis': 'internet_information_services',
    'exim': 'exim',
    'postfix': 'postfix',
    'dovecot': 'dovecot',
    'vsftpd': 'vsftpd',
    'proftpd': 'proftpd',
    'samba': 'samba',
    'bind': 'bind',
    'named': 'bind',
    'elasticsearch': 'elasticsearch',
  };

  for (const [key, cpe] of Object.entries(mapping)) {
    if (lower.includes(key)) return cpe;
  }
  return null;
}

/**
 * Extract a CVSS score from NVD CVE item.
 * Prefers CVSS v3.1, falls back to v2.
 */
function getCvssScore(item: NvdCveItem): number {
  const v31 = item.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore;
  if (v31 !== undefined) return v31;
  const v2 = item.cve.metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore;
  if (v2 !== undefined) return v2;
  return 0;
}

/**
 * Map CVSS score to severity level.
 */
function cvssToSeverity(score: number): Severity {
  if (score >= 9.0) return 'critical';
  if (score >= 7.0) return 'high';
  if (score >= 4.0) return 'medium';
  return 'low';
}

/** Get English description from NVD CVE item. */
function getDescription(item: NvdCveItem): string {
  return item.cve.descriptions.find(d => d.lang === 'en')?.value
    ?? item.cve.descriptions[0]?.value
    ?? 'No description available';
}

/** Sleep utility */
function sleep(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Query NVD API for CVEs matching a keyword + version.
 */
async function queryNvd(keyword: string, version?: string): Promise<NvdCveItem[]> {
  const params = new URLSearchParams({
    keywordSearch: version ? `${keyword} ${version}` : keyword,
    resultsPerPage: '20',
  });

  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);

  try {
    const res = await fetch(`${NVD_API_BASE}?${params.toString()}`, {
      signal: controller.signal,
      headers: { 'Accept': 'application/json' },
    });

    if (!res.ok) {
      if (res.status === 403 || res.status === 429) {
        logger.warn(`NVD rate limited (${res.status}), waiting...`);
        await sleep(API_DELAY_MS * 3);
        return [];
      }
      logger.warn(`NVD API returned ${res.status}`);
      return [];
    }

    const data = await res.json() as NvdResponse;
    return data.vulnerabilities ?? [];
  } catch (err) {
    if (err instanceof Error && err.name === 'AbortError') {
      logger.warn('NVD API request timed out');
    } else {
      logger.warn(`NVD API query failed: ${err instanceof Error ? err.message : String(err)}`);
    }
    return [];
  } finally {
    clearTimeout(timer);
  }
}

/**
 * Check detected services against NVD for known CVEs.
 * Only runs in 'full' scan depth.
 *
 * @param openPorts - Detected open ports with service info
 * @returns Array of CVE findings
 */
export async function checkCVEs(openPorts: PortInfo[]): Promise<Finding[]> {
  const findings: Finding[] = [];
  const checkedKeywords = new Set<string>();

  // Extract unique services to check
  const servicesToCheck: Array<{ keyword: string; port: number }> = [];

  for (const port of openPorts) {
    const service = port.service ?? '';
    const keyword = serviceToCpeKeyword(service);
    if (!keyword) continue;

    if (checkedKeywords.has(keyword)) continue;
    checkedKeywords.add(keyword);

    servicesToCheck.push({ keyword, port: port.port });
  }

  if (servicesToCheck.length === 0) {
    logger.info('No mappable services found for CVE check');
    return findings;
  }

  logger.info(`Checking ${servicesToCheck.length} service(s) against NVD`);

  for (const svc of servicesToCheck) {
    logger.info(`Querying NVD: ${svc.keyword} (port ${svc.port})`);

    const items = await queryNvd(svc.keyword);

    // Filter by CVSS score and take top N
    const relevant = items
      .filter(item => getCvssScore(item) >= MIN_CVSS_SCORE)
      .sort((a, b) => getCvssScore(b) - getCvssScore(a))
      .slice(0, MAX_CVES_PER_SERVICE);

    for (const item of relevant) {
      const score = getCvssScore(item);
      const description = getDescription(item);
      const severity = cvssToSeverity(score);
      const cveId = item.cve.id;
      const ref = item.cve.references?.[0]?.url;

      findings.push({
        id: `CVE-${cveId}`,
        title: `${cveId} - ${svc.keyword} (CVSS ${score})`,
        description: description.length > 300 ? description.slice(0, 297) + '...' : description,
        severity,
        category: 'vulnerability_management',
        remediation: `Patch or upgrade ${svc.keyword} to a version not affected by ${cveId}. CVSS: ${score}/10.${ref ? ` Ref: ${ref}` : ''}`,
        details: `Port: ${svc.port}, Service: ${svc.keyword}, CVSS: ${score}`,
      });
    }

    // Rate limit: wait between requests
    if (servicesToCheck.indexOf(svc) < servicesToCheck.length - 1) {
      await sleep(API_DELAY_MS);
    }
  }

  logger.info(`CVE check complete: ${findings.length} finding(s)`);
  return findings;
}
